package morphir:ir@0.4.0;

/// Type system definitions
interface types {
    use document.{document-value};
    use naming.{type-attributes, name, fqname, type-variable};

    /// Record field
    record field {
        field-name: name,
        field-type: ir-type,
    }

    /// Constructor for custom types
    record type-ctor {
        ctor-name: name,
        args: list<tuple<name, ir-type>>,
    }

    /// Type expression (uses type-attributes: none or metadata)
    variant ir-type {
        /// Type variable: `a`, `comparable`
        variable(tuple<type-attributes, type-variable>),

        /// Reference to named type: `String`, `List a`
        reference(tuple<type-attributes, fqname, list<ir-type>>),

        /// Tuple: `(Int, String)`
        %tuple(tuple<type-attributes, list<ir-type>>),

        /// Record: `{ name: String, age: Int }`
        %record(tuple<type-attributes, list<field>>),

        /// Extensible record: `{ a | name: String }`
        extensible-record(tuple<type-attributes, type-variable, list<field>>),

        /// Function: `Int -> String`
        %function(tuple<type-attributes, ir-type, ir-type>),

        /// Unit type: `()`
        unit(type-attributes),
    }

    /// Value-level attributes (expressions carry their type)
    variant value-attributes {
        /// Just the inferred/checked type
        typed(ir-type),
        /// Type plus custom metadata
        typed-with-meta(tuple<ir-type, document-value>),
    }

    /// Access control
    enum access {
        public,
        private,
    }

    /// Access-controlled wrapper
    record access-controlled-constructors {
        access: access,
        constructors: list<type-ctor>,
    }

    /// Type specification (public interface)
    variant type-specification {
        /// Type alias visible to consumers
        type-alias-specification(tuple<list<type-variable>, ir-type>),

        /// Opaque type (no structure visible)
        opaque-type-specification(list<type-variable>),

        /// Custom type with public constructors
        custom-type-specification(tuple<list<type-variable>, list<type-ctor>>),

        /// Derived type with conversion functions
        derived-type-specification(tuple<list<type-variable>, derived-type-details>),
    }

    /// Details for derived types
    record derived-type-details {
        base-type: ir-type,
        from-base-type: fqname,
        to-base-type: fqname,
    }

    /// Hole reason for incomplete types
    variant hole-reason {
        unresolved-reference(fqname),
        deleted-during-refactor(string),
        type-mismatch(tuple<string, string>),
    }

    /// Incompleteness marker
    variant incompleteness {
        hole(hole-reason),
        draft(option<string>),
    }

    /// Type definition (implementation)
    variant type-definition {
        /// Custom type (sum type)
        custom-type-definition(tuple<list<type-variable>, access-controlled-constructors>),

        /// Type alias
        type-alias-definition(tuple<list<type-variable>, ir-type>),

        /// Incomplete type (v4)
        incomplete-type-definition(tuple<list<type-variable>, incompleteness, option<ir-type>>),
    }
}
