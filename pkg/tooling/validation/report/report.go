// Package report provides validation report generation in various formats.
package report

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/finos/morphir/pkg/tooling/validation"
)

// Format represents the output format for reports.
type Format string

const (
	// FormatMarkdown generates a Markdown report.
	FormatMarkdown Format = "markdown"
)

// ErrorCode represents a unique identifier for a validation error type.
type ErrorCode string

const (
	// E001 Pattern Mismatch - value doesn't match required naming pattern.
	E001 ErrorCode = "E001"
	// E002 Type Variant Mismatch - value doesn't match any expected type variants (oneOf).
	E002 ErrorCode = "E002"
	// E003 Constraint Validation Failed - value doesn't satisfy all required constraints (allOf).
	E003 ErrorCode = "E003"
	// E004 Missing Required Fields - required properties are missing from object.
	E004 ErrorCode = "E004"
	// E005 Array Length Mismatch - array has wrong number of elements.
	E005 ErrorCode = "E005"
	// E006 Type Mismatch (Array vs Object) - expected array but got object or vice versa.
	E006 ErrorCode = "E006"
	// E007 Null Value - null found where value was required.
	E007 ErrorCode = "E007"
	// E000 Other Validation Error - unclassified validation error.
	E000 ErrorCode = "E000"
)

// ErrorCodeInfo contains the title and description for an error code.
type ErrorCodeInfo struct {
	Title       string
	Description string
}

// errorCodeRegistry maps error codes to their information.
var errorCodeRegistry = map[ErrorCode]ErrorCodeInfo{
	E001: {
		Title: "Pattern Mismatch",
		Description: "The value doesn't match the required naming pattern. Each name part must be " +
			"either a lowercase word (starting with a letter) or a standalone number. " +
			"The Morphir IR schema requires identifiers to follow specific naming conventions.",
	},
	E002: {
		Title: "Type Variant Mismatch",
		Description: "The value doesn't match any of the expected type variants (oneOf constraint). " +
			"This usually means the IR structure differs from the schema definition. " +
			"This often occurs when the IR was generated by a different version of the Morphir toolchain.",
	},
	E003: {
		Title: "Constraint Validation Failed",
		Description: "The value doesn't satisfy all required constraints (allOf constraint). " +
			"Check that all required fields are present and correctly formatted.",
	},
	E004: {
		Title: "Missing Required Fields",
		Description: "Required fields are missing from this object. Add the missing properties " +
			"listed in the error message to resolve this issue.",
	},
	E005: {
		Title: "Array Length Mismatch",
		Description: "The array has the wrong number of elements (minItems/maxItems constraint). " +
			"Check the IR structure against the schema specification.",
	},
	E006: {
		Title: "Type Mismatch",
		Description: "Expected an array but found an object, or vice versa. " +
			"This may indicate a version mismatch between the IR and schema.",
	},
	E007: {
		Title: "Null Value",
		Description: "A null value was found where a value was required. " +
			"Ensure all required fields have values.",
	},
	E000: {
		Title: "Other Validation Error",
		Description: "An unclassified validation error occurred. " +
			"Review the error message for specific details.",
	},
}

// GetErrorCodeInfo returns the information for an error code.
func GetErrorCodeInfo(code ErrorCode) ErrorCodeInfo {
	if info, ok := errorCodeRegistry[code]; ok {
		return info
	}
	return errorCodeRegistry[E000]
}

// Generator generates validation reports.
type Generator interface {
	// Generate creates a report from the validation result.
	Generate(result *validation.Result) string
}

// NewGenerator creates a new report generator for the specified format.
func NewGenerator(format Format) Generator {
	switch format {
	case FormatMarkdown:
		return &MarkdownGenerator{}
	default:
		return &MarkdownGenerator{}
	}
}

// ParsedError represents a parsed validation error with context.
type ParsedError struct {
	Path        string
	Message     string
	Expected    string
	Actual      string
	Suggestion  string
	NestedPaths []string
	Code        ErrorCode
}

// parseValidationError extracts structured information from a validation error string.
func parseValidationError(errStr string) []ParsedError {
	var errors []ParsedError

	// Pattern to match path and message: "at '/path': message"
	pathPattern := regexp.MustCompile(`at '([^']+)':\s*(.+)`)

	lines := strings.Split(errStr, "\n")
	for _, line := range lines {
		// Remove leading dashes, whitespace, and indentation but preserve the content
		line = strings.TrimSpace(line)
		// Remove multiple leading "- " for nested errors
		for strings.HasPrefix(line, "- ") {
			line = strings.TrimPrefix(line, "- ")
			line = strings.TrimSpace(line)
		}

		if line == "" {
			continue
		}

		matches := pathPattern.FindStringSubmatch(line)
		if len(matches) >= 3 {
			path := matches[1]
			message := matches[2]

			// Skip intermediate "validation failed" messages - we want the leaf errors
			if message == "validation failed" {
				continue
			}

			parsed := ParsedError{
				Path:    path,
				Message: message,
			}

			// Extract expected/actual from common patterns
			if strings.Contains(message, "value must be") {
				parsed.Expected = extractAfter(message, "value must be ")
			}
			if strings.Contains(message, "got ") {
				parts := strings.SplitN(message, "got ", 2)
				if len(parts) == 2 {
					parsed.Actual = strings.TrimSuffix(strings.Split(parts[1], ",")[0], ")")
				}
			}
			if strings.Contains(message, "want ") {
				parts := strings.SplitN(message, "want ", 2)
				if len(parts) == 2 {
					parsed.Expected = strings.TrimSpace(parts[1])
				}
			}
			if strings.Contains(message, "does not match pattern") {
				// Extract the pattern from messages like "'2052' does not match pattern '^[a-z][a-z0-9]*$'"
				patternMatch := regexp.MustCompile(`'([^']+)' does not match pattern '([^']+)'`).FindStringSubmatch(message)
				if len(patternMatch) >= 3 {
					parsed.Actual = patternMatch[1]
					parsed.Expected = "pattern " + patternMatch[2]
				}
			}

			// Generate suggestions and assign error code based on error type
			parsed.Suggestion = generateSuggestion(parsed)
			parsed.Code = assignErrorCode(parsed)

			errors = append(errors, parsed)
		}
	}

	// If no structured errors found, create a generic one
	if len(errors) == 0 && errStr != "" {
		errors = append(errors, ParsedError{
			Path:    "/",
			Message: errStr,
			Code:    E000,
		})
	}

	return errors
}

func extractAfter(s, prefix string) string {
	idx := strings.Index(s, prefix)
	if idx == -1 {
		return ""
	}
	result := s[idx+len(prefix):]
	// Trim quotes and trailing punctuation
	result = strings.Trim(result, "\"' ")
	return result
}

func generateSuggestion(err ParsedError) string {
	msg := strings.ToLower(err.Message)

	switch {
	case strings.Contains(msg, "pattern"):
		return "The value doesn't match the required naming pattern. Each name part must be either a lowercase word (starting with a letter) or a standalone number."

	case strings.Contains(msg, "oneof failed"):
		return "The value doesn't match any of the expected type variants. This usually means the IR structure differs from the schema definition."

	case strings.Contains(msg, "allof failed"):
		return "The value doesn't satisfy all required constraints. Check that all required fields are present and correctly formatted."

	case strings.Contains(msg, "missing properties"):
		return "Required fields are missing from this object. Add the missing properties listed in the error."

	case strings.Contains(msg, "minitems") || strings.Contains(msg, "maxitems"):
		return "The array has the wrong number of elements. Check the IR structure against the schema specification."

	case strings.Contains(msg, "got array, want object"):
		return "Expected an object but found an array. This may indicate a version mismatch between the IR and schema."

	case strings.Contains(msg, "got object, want array"):
		return "Expected an array but found an object. This may indicate a version mismatch between the IR and schema."

	case strings.Contains(msg, "got null"):
		return "A null value was found where a value was required. Ensure all required fields have values."

	default:
		return ""
	}
}

// assignErrorCode determines the error code based on the error message.
func assignErrorCode(err ParsedError) ErrorCode {
	msg := strings.ToLower(err.Message)

	switch {
	case strings.Contains(msg, "pattern"):
		return E001
	case strings.Contains(msg, "oneof failed"):
		return E002
	case strings.Contains(msg, "allof failed"):
		return E003
	case strings.Contains(msg, "missing properties"):
		return E004
	case strings.Contains(msg, "minitems") || strings.Contains(msg, "maxitems"):
		return E005
	case strings.Contains(msg, "got array, want object") || strings.Contains(msg, "got object, want array"):
		return E006
	case strings.Contains(msg, "got null"):
		return E007
	default:
		return E000
	}
}

// explainJSONPath provides a human-readable explanation of a JSON path.
// It understands the Morphir IR structure to provide meaningful descriptions.
func explainJSONPath(path string) string {
	parts := strings.Split(strings.TrimPrefix(path, "/"), "/")

	var explanations []string
	context := &pathContext{}

	for i, part := range parts {
		explanation := context.explainPart(part, i, parts)
		if explanation != "" {
			explanations = append(explanations, explanation)
		}
	}

	if len(explanations) == 0 {
		return path
	}

	return strings.Join(explanations, " â†’ ")
}

// pathContext tracks the semantic context while parsing a JSON path.
type pathContext struct {
	inDistribution bool
	inModules      bool
	inModuleEntry  bool
	inModuleName   bool
	inModuleDef    bool
	inTypes        bool
	inValues       bool
	inTypeEntry    bool
	inValueEntry   bool
	depth          int
}

// explainPart returns a human-readable explanation for a single path component.
func (ctx *pathContext) explainPart(part string, idx int, parts []string) string {
	// Handle named keys
	switch part {
	case "distribution":
		ctx.inDistribution = true
		return "Distribution"

	case "modules":
		ctx.inModules = true
		return "modules"

	case "types":
		ctx.inTypes = true
		return "type definitions"

	case "values":
		ctx.inValues = true
		return "value definitions"

	case "value":
		return "value"

	case "body":
		return "function body"

	case "doc":
		return "documentation"

	case "inputTypes":
		return "input parameters"

	case "outputType":
		return "output type"

	case "access":
		return "access control"

	case "inputs":
		return "inputs"

	case "output":
		return "output"

	case "tpe":
		return "type"

	case "name":
		return "name"
	}

	// Handle numeric indices based on context
	if isNumeric(part) {
		return ctx.explainNumericIndex(part, idx, parts)
	}

	return ""
}

// explainNumericIndex provides meaningful descriptions for array indices.
func (ctx *pathContext) explainNumericIndex(part string, idx int, parts []string) string {
	index := part

	// Distribution array: ["Library", PackageName, Dependencies, PackageDefinition]
	if ctx.inDistribution && !ctx.inModules && !ctx.inTypes && !ctx.inValues {
		switch part {
		case "0":
			return "type tag"
		case "1":
			return "Package Name"
		case "2":
			return "Dependencies"
		case "3":
			return "Package Definition"
		}
	}

	// Module entry: [ModuleName, AccessControlled<ModuleDefinition>]
	if ctx.inModules {
		ctx.depth++

		// First numeric after "modules" is module index
		if ctx.depth == 1 {
			ctx.inModuleEntry = true
			return fmt.Sprintf("module #%s", index)
		}
		// Second numeric (depth 2) is [0]=ModuleName, [1]=ModuleDefinition
		if ctx.depth == 2 && ctx.inModuleEntry {
			switch part {
			case "0":
				ctx.inModuleName = true
				return "Module Name (Path)"
			case "1":
				ctx.inModuleDef = true
				return "Module Definition"
			}
		}
		// Within Module Name: Path of Names, each Name is array of strings
		if ctx.inModuleName {
			if ctx.depth == 3 {
				return fmt.Sprintf("Name part #%s", index)
			}
			if ctx.depth >= 4 {
				return fmt.Sprintf("segment #%s (must be lowercase)", index)
			}
		}
	}

	// Type entry: [Name, AccessControlled<TypeDefinition>]
	if ctx.inTypes {
		ctx.depth++
		if ctx.depth == 1 {
			ctx.inTypeEntry = true
			return fmt.Sprintf("type #%s", index)
		}
		if ctx.depth == 2 {
			switch part {
			case "0":
				return "Type Name"
			case "1":
				return "Type Definition"
			}
		}
	}

	// Value entry: [Name, AccessControlled<ValueDefinition>]
	if ctx.inValues {
		ctx.depth++
		if ctx.depth == 1 {
			ctx.inValueEntry = true
			return fmt.Sprintf("value #%s", index)
		}
		if ctx.depth == 2 {
			switch part {
			case "0":
				return "Value Name"
			case "1":
				return "Value Definition"
			}
		}
	}

	return fmt.Sprintf("element #%s", index)
}

func isNumeric(s string) bool {
	for _, c := range s {
		if c < '0' || c > '9' {
			return false
		}
	}
	return len(s) > 0
}

// countUniqueIssues counts unique issue types from parsed errors.
func countUniqueIssues(errors []ParsedError) map[string]int {
	counts := make(map[string]int)
	for _, e := range errors {
		msg := e.Message
		// Normalize the message to group similar issues
		switch {
		case strings.Contains(msg, "pattern"):
			counts["Pattern mismatch"]++
		case strings.Contains(msg, "oneOf failed"):
			counts["Type variant mismatch"]++
		case strings.Contains(msg, "allOf failed"):
			counts["Constraint validation failed"]++
		case strings.Contains(msg, "missing properties"):
			counts["Missing required fields"]++
		case strings.Contains(msg, "minItems") || strings.Contains(msg, "maxItems"):
			counts["Array length mismatch"]++
		default:
			counts["Other validation errors"]++
		}
	}
	return counts
}
