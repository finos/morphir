package report

import (
	"fmt"
	"strings"
	"time"

	"github.com/finos/morphir/pkg/tooling/validation"
)

// MarkdownGenerator generates validation reports in Markdown format.
type MarkdownGenerator struct{}

// usedCodes tracks which error codes have been used in a report.
type usedCodes map[ErrorCode]struct{}

// Generate creates a Markdown report from a single validation result.
func (g *MarkdownGenerator) Generate(result *validation.Result) string {
	return g.GenerateMultiple([]*validation.Result{result})
}

// GenerateMultiple creates a Markdown report from multiple validation results.
func (g *MarkdownGenerator) GenerateMultiple(results []*validation.Result) string {
	var sb strings.Builder
	codes := make(usedCodes)

	g.writeHeader(&sb, results)
	g.writeOverallSummary(&sb, results)

	for i, result := range results {
		g.writeFileSection(&sb, result, i+1, len(results), codes)
	}

	g.writeAppendix(&sb, codes)
	g.writeFooter(&sb)

	return sb.String()
}

func (g *MarkdownGenerator) writeHeader(sb *strings.Builder, results []*validation.Result) {
	sb.WriteString("# Morphir IR Validation Report\n\n")

	// Overall status
	allValid := true
	for _, r := range results {
		if !r.Valid {
			allValid = false
			break
		}
	}

	if allValid {
		sb.WriteString("âœ… **Overall Status: ALL VALID**\n\n")
	} else {
		sb.WriteString("âŒ **Overall Status: VALIDATION ERRORS FOUND**\n\n")
	}
}

func (g *MarkdownGenerator) writeOverallSummary(sb *strings.Builder, results []*validation.Result) {
	sb.WriteString("## Validation Summary\n\n")

	validCount := 0
	invalidCount := 0
	totalErrors := 0

	for _, r := range results {
		if r.Valid {
			validCount++
		} else {
			invalidCount++
			totalErrors += len(r.Errors)
		}
	}

	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	_, _ = fmt.Fprintf(sb, "| Files Validated | %d |\n", len(results))
	_, _ = fmt.Fprintf(sb, "| Passed | %d |\n", validCount)
	_, _ = fmt.Fprintf(sb, "| Failed | %d |\n", invalidCount)
	_, _ = fmt.Fprintf(sb, "| Total Errors | %d |\n", totalErrors)
	sb.WriteString("\n")

	// File list with status
	sb.WriteString("### Files\n\n")
	sb.WriteString("| File | Version | Status |\n")
	sb.WriteString("|------|---------|--------|\n")
	for _, r := range results {
		status := "âœ… Valid"
		if !r.Valid {
			status = fmt.Sprintf("âŒ %d error(s)", len(r.Errors))
		}
		_, _ = fmt.Fprintf(sb, "| `%s` | v%d | %s |\n", r.Path, r.Version, status)
	}
	sb.WriteString("\n")
}

func (g *MarkdownGenerator) writeFileSection(sb *strings.Builder, result *validation.Result, index, total int, codes usedCodes) {
	if total > 1 {
		_, _ = fmt.Fprintf(sb, "## File %d of %d: %s\n\n", index, total, result.Path)
	} else {
		_, _ = fmt.Fprintf(sb, "## File: %s\n\n", result.Path)
	}

	g.writeFileSummary(sb, result)

	if !result.Valid {
		g.writeErrorAnalysis(sb, result)
		g.writeDetailedErrors(sb, result, codes)
		g.writeRecommendations(sb, result)
	}
}

func (g *MarkdownGenerator) writeFileSummary(sb *strings.Builder, result *validation.Result) {
	sb.WriteString("### Details\n\n")
	sb.WriteString("| Property | Value |\n")
	sb.WriteString("|----------|-------|\n")
	_, _ = fmt.Fprintf(sb, "| Path | `%s` |\n", result.Path)
	_, _ = fmt.Fprintf(sb, "| Format Version | %d |\n", result.Version)
	_, _ = fmt.Fprintf(sb, "| Schema | `morphir-ir-v%d.json` |\n", result.Version)

	if result.Valid {
		sb.WriteString("| Status | âœ… Valid |\n")
		sb.WriteString("| Errors | 0 |\n")
	} else {
		sb.WriteString("| Status | âŒ Invalid |\n")
		_, _ = fmt.Fprintf(sb, "| Errors | %d |\n", len(result.Errors))
	}
	sb.WriteString("\n")
}

func (g *MarkdownGenerator) writeErrorAnalysis(sb *strings.Builder, result *validation.Result) {
	sb.WriteString("### Error Analysis\n\n")

	// Parse all errors
	var allParsed []ParsedError
	for _, errStr := range result.Errors {
		parsed := parseValidationError(errStr)
		allParsed = append(allParsed, parsed...)
	}

	// Count unique issue types
	issueCounts := countUniqueIssues(allParsed)

	sb.WriteString("#### Issue Categories\n\n")
	sb.WriteString("| Issue Type | Count |\n")
	sb.WriteString("|------------|-------|\n")
	for issueType, count := range issueCounts {
		_, _ = fmt.Fprintf(sb, "| %s | %d |\n", issueType, count)
	}
	sb.WriteString("\n")

	// Explain what the issues mean
	sb.WriteString("#### Understanding the Issues\n\n")

	if _, ok := issueCounts["Pattern mismatch"]; ok {
		sb.WriteString("**Pattern Mismatch:** Some identifiers don't follow the required naming conventions. ")
		sb.WriteString("The Morphir IR schema requires that certain names (like module names and type parameters) ")
		sb.WriteString("follow specific patterns, typically lowercase letters and numbers.\n\n")
	}

	if _, ok := issueCounts["Type variant mismatch"]; ok {
		sb.WriteString("**Type Variant Mismatch:** The IR contains structures that don't match any of the expected type variants. ")
		sb.WriteString("This often occurs when the IR was generated by a different version of the Morphir toolchain ")
		sb.WriteString("than the schema version being used for validation.\n\n")
	}

	if _, ok := issueCounts["Constraint validation failed"]; ok {
		sb.WriteString("**Constraint Validation Failed:** Some values don't satisfy all required constraints. ")
		sb.WriteString("This may indicate missing required fields or incorrectly formatted values.\n\n")
	}

	if _, ok := issueCounts["Missing required fields"]; ok {
		sb.WriteString("**Missing Required Fields:** Some objects are missing required properties. ")
		sb.WriteString("Check that all required fields are populated in the IR.\n\n")
	}
}

func (g *MarkdownGenerator) writeDetailedErrors(sb *strings.Builder, result *validation.Result, codes usedCodes) {
	sb.WriteString("### Detailed Errors\n\n")

	// Create context extractor for showing JSON snippets
	extractor := DefaultContextExtractor()

	for i, errStr := range result.Errors {
		_, _ = fmt.Fprintf(sb, "#### Error %d\n\n", i+1)

		parsed := parseValidationError(errStr)

		// Show a subset of the most relevant errors
		maxErrors := 5
		if len(parsed) > maxErrors {
			_, _ = fmt.Fprintf(sb, "> Showing first %d of %d validation errors\n\n", maxErrors, len(parsed))
			parsed = parsed[:maxErrors]
		}

		for _, p := range parsed {
			// Track the error code as used
			codes[p.Code] = struct{}{}

			_, _ = fmt.Fprintf(sb, "**Path:** `%s`\n\n", p.Path)

			pathExplanation := explainJSONPath(p.Path)
			if pathExplanation != p.Path {
				_, _ = fmt.Fprintf(sb, "**Location:** %s\n\n", pathExplanation)
			}

			// Include error code inline with the issue message
			_, _ = fmt.Fprintf(sb, "**Issue:** [%s] %s\n\n", p.Code, p.Message)

			if p.Expected != "" {
				_, _ = fmt.Fprintf(sb, "- Expected: `%s`\n", p.Expected)
			}
			if p.Actual != "" {
				_, _ = fmt.Fprintf(sb, "- Actual: `%s`\n", p.Actual)
			}

			// Extract and show JSON context if we have raw data
			if result.RawData != nil && p.Path != "" && p.Path != "/" {
				// Get the parent context to show surrounding structure
				parentContext := extractor.ExtractContextWithParent(result.RawData, p.Path)

				// Also try to get the Name/Path value for friendly display
				parentPath := getParentPath(p.Path)
				parentValue := extractor.NavigateToPath(result.RawData, parentPath)

				// If the parent is a Name (array of strings), show its friendly representation
				if parentValue != nil && IsNameArray(parentValue) {
					friendlyName := FormatMorphirName(parentValue)
					if friendlyName != "" {
						_, _ = fmt.Fprintf(sb, "\n**Name:** `%s`\n", friendlyName)
					}
				} else if parentValue != nil && IsPathArray(parentValue) {
					// If it's a Path (array of Names), show its friendly representation
					friendlyPath := FormatMorphirPath(parentValue)
					if friendlyPath != "" {
						_, _ = fmt.Fprintf(sb, "\n**Full Path:** `%s`\n", friendlyPath)
					}
				}

				if parentContext != "" {
					sb.WriteString("\n**Context:**\n\n")
					sb.WriteString("```json\n")
					_, _ = fmt.Fprintf(sb, "// At: %s\n", p.Path)
					sb.WriteString(parentContext)
					sb.WriteString("\n```\n")
				}
			}

			if p.Suggestion != "" {
				_, _ = fmt.Fprintf(sb, "\nðŸ’¡ **Suggestion:** %s\n", p.Suggestion)
			}

			sb.WriteString("\n---\n\n")
		}
	}
}

func (g *MarkdownGenerator) writeRecommendations(sb *strings.Builder, result *validation.Result) {
	sb.WriteString("### Recommendations\n\n")

	sb.WriteString("Based on the validation errors, consider the following:\n\n")

	sb.WriteString("1. **Check Morphir Version Compatibility**\n")
	_, _ = fmt.Fprintf(sb, "   - Your IR uses format version %d\n", result.Version)
	sb.WriteString("   - Ensure the IR was generated with a compatible version of morphir-elm\n")
	sb.WriteString("   - The morphir-go schema may have stricter validation than morphir-elm\n\n")

	sb.WriteString("2. **Regenerate the IR**\n")
	sb.WriteString("   - Try regenerating the IR with the latest version of morphir-elm\n")
	sb.WriteString("   - Run `morphir-elm make` to rebuild your project\n\n")

	sb.WriteString("3. **Report Compatibility Issues**\n")
	sb.WriteString("   - If the IR was generated correctly but fails validation, this may indicate\n")
	sb.WriteString("     a schema compatibility issue between morphir-elm and morphir-go\n")
	sb.WriteString("   - Please report issues at: https://github.com/finos/morphir/issues\n\n")
}

func (g *MarkdownGenerator) writeAppendix(sb *strings.Builder, codes usedCodes) {
	if len(codes) == 0 {
		return
	}

	sb.WriteString("## Appendix: Error Code Reference\n\n")

	// Sort codes for consistent output
	orderedCodes := []ErrorCode{E001, E002, E003, E004, E005, E006, E007, E000}
	for _, code := range orderedCodes {
		if _, used := codes[code]; used {
			info := GetErrorCodeInfo(code)
			_, _ = fmt.Fprintf(sb, "### %s: %s\n\n", code, info.Title)
			sb.WriteString(info.Description)
			sb.WriteString("\n\n")
		}
	}
}

func (g *MarkdownGenerator) writeFooter(sb *strings.Builder) {
	sb.WriteString("---\n\n")
	_, _ = fmt.Fprintf(sb, "*Report generated by morphir-go at %s*\n", time.Now().Format(time.RFC3339))
}
