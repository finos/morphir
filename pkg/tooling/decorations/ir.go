package decorations

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	ir "github.com/finos/morphir/pkg/models/ir"
	jsoncodec "github.com/finos/morphir/pkg/models/ir/codec/json"
	decorationmodels "github.com/finos/morphir/pkg/models/ir/decorations"
)

// LoadDecorationIR loads a decoration schema IR file from the given path.
//
// The path should point to a Morphir IR JSON file (typically generated by
// `morphir-elm make` or similar tools). The file is decoded into a Morphir
// Distribution which can then be used to validate entry points and extract
// type definitions.
func LoadDecorationIR(irPath string) (decorationmodels.DecorationIR, error) {
	absPath, err := filepath.Abs(irPath)
	if err != nil {
		return decorationmodels.DecorationIR{}, fmt.Errorf("resolve IR path: %w", err)
	}

	data, err := os.ReadFile(absPath)
	if err != nil {
		return decorationmodels.DecorationIR{}, fmt.Errorf("read IR file: %w", err)
	}

	// Decode the distribution using the JSON codec
	// Default to v3 format (most common), could auto-detect from formatVersion field
	opts := jsoncodec.Options{
		FormatVersion: jsoncodec.FormatV3,
	}

	var raw json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return decorationmodels.DecorationIR{}, fmt.Errorf("parse JSON: %w", err)
	}

	// Check if this is a distribution format (has formatVersion and distribution)
	var wrapper struct {
		FormatVersion *int            `json:"formatVersion"`
		Distribution  json.RawMessage `json:"distribution"`
	}
	if err := json.Unmarshal(data, &wrapper); err == nil && wrapper.FormatVersion != nil && wrapper.Distribution != nil {
		// This is a wrapped distribution format
		dist, err := jsoncodec.DecodeDistribution(opts, wrapper.Distribution)
		if err != nil {
			return decorationmodels.DecorationIR{}, fmt.Errorf("decode distribution: %w", err)
		}
		return decorationmodels.NewDecorationIR(dist, absPath), nil
	}

	// Try decoding as direct distribution (array format)
	dist, err := jsoncodec.DecodeDistribution(opts, raw)
	if err != nil {
		return decorationmodels.DecorationIR{}, fmt.Errorf("decode distribution: %w", err)
	}

	return decorationmodels.NewDecorationIR(dist, absPath), nil
}

// ValidateEntryPoint validates that an entry point FQName exists in the decoration IR.
//
// The entryPoint should be in the format: PackageName:ModuleName:TypeName
// (e.g., "My.Amazing.Decoration:Foo:Shape").
//
// Returns an error if:
//   - The entry point format is invalid
//   - The package name doesn't match the decoration IR
//   - The module doesn't exist in the decoration IR
//   - The type doesn't exist in the module
func ValidateEntryPoint(decIR decorationmodels.DecorationIR, entryPoint string) error {
	// Parse the entry point FQName
	fqName, err := ir.ParseFQName(entryPoint)
	if err != nil {
		return fmt.Errorf("parse entry point: %w", err)
	}

	// Validate package name matches
	lib, ok := decIR.Distribution().(ir.Library)
	if !ok {
		return fmt.Errorf("decoration IR must be a Library distribution")
	}

	pkgName := lib.PackageName()
	entryPkgPath := fqName.PackagePath()

	if !pkgName.Equal(entryPkgPath) {
		return fmt.Errorf("package name mismatch: entry point has %q, but IR has %q",
			entryPkgPath.ToString(func(n ir.Name) string { return n.ToTitleCase() }, "."),
			pkgName.ToString(func(n ir.Name) string { return n.ToTitleCase() }, "."))
	}

	// Find the module in the package definition
	entryModulePath := fqName.ModulePath()
	def := lib.Definition()

	var foundModule *ir.ModuleDefinition[ir.Unit, ir.Type[ir.Unit]]
	for _, mod := range def.Modules() {
		if mod.Name().Equal(entryModulePath) {
			// Get the module definition (wrapped in AccessControlled)
			modDef := mod.Definition()
			// Unwrap AccessControlled to get the actual module definition
			unwrapped := modDef.Value()
			foundModule = &unwrapped
			break
		}
	}

	if foundModule == nil {
		return fmt.Errorf("module %q not found in decoration IR",
			entryModulePath.ToString(func(n ir.Name) string { return n.ToTitleCase() }, "."))
	}

	// Find the type in the module
	entryTypeName := fqName.LocalName()
	types := foundModule.Types()

	for _, typeDef := range types {
		if typeDef.Name().Equal(entryTypeName) {
			// Found the type! Validate that it's accessible
			// (we'll check access control, but for decorations we typically want public types)
			typeDefAccess := typeDef.Definition()
			// Note: We check access but don't enforce it - private types can still be used
			// for decorations in some cases. This is intentionally permissive.
			_ = typeDefAccess.Access()
			// Found the type!
			return nil
		}
	}

	return fmt.Errorf("type %q not found in module %q",
		entryTypeName.ToCamelCase(),
		entryModulePath.ToString(func(n ir.Name) string { return n.ToTitleCase() }, "."))
}

// ExtractDecorationType extracts the type definition for the entry point from the decoration IR.
//
// Returns the type definition for the decoration shape, which can be used
// to validate decoration values. The type definition contains the full type
// information including constructors for custom types.
func ExtractDecorationType(decIR decorationmodels.DecorationIR, entryPoint string) (ir.TypeDefinition[ir.Unit], error) {
	// First validate the entry point exists
	if err := ValidateEntryPoint(decIR, entryPoint); err != nil {
		return nil, fmt.Errorf("validate entry point: %w", err)
	}

	// Parse the entry point FQName
	fqName, err := ir.ParseFQName(entryPoint)
	if err != nil {
		return nil, fmt.Errorf("parse entry point: %w", err)
	}

	// Find the module and type
	lib := decIR.Distribution().(ir.Library)
	def := lib.Definition()
	entryModulePath := fqName.ModulePath()
	entryTypeName := fqName.LocalName()

	for _, mod := range def.Modules() {
		if mod.Name().Equal(entryModulePath) {
			modDef := mod.Definition().Value()
			types := modDef.Types()

			for _, typeDef := range types {
				if typeDef.Name().Equal(entryTypeName) {
					// Get the type definition (unwrapping AccessControlled and Documented)
					typeDefAccess := typeDef.Definition()
					typeDefDoc := typeDefAccess.Value()
					typeDefValue := typeDefDoc.Value()
					return typeDefValue, nil
				}
			}
		}
	}

	// This shouldn't happen if ValidateEntryPoint passed, but handle it anyway
	return nil, fmt.Errorf("type %q not found (validation should have caught this)", entryPoint)
}
